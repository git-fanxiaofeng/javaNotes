

# 面试准备总结

##  (java基础)

###  ==与equals方法的区别

 对于基本数据类型，没有equals方法，只能使用 == 来进行比较，比较的是两个基本类型的值

 对于引用数据类型，== 比较的是内存地址值，equals 方法存在于object类，使用时通常会重写equals方法，一般重写后比较的是堆中的内容是否相等，比如string类和包装类都对equals方法进行了重写，如果没有重写，默认使用object中的equals方法等价于==，比较的内存地址值。

### hashCode 与 equals 方法

 1、如果两个对象相同（即：用 equals 比较返回true），那么它们的 hashCode 值一定要相同；

 2、如果两个对象的 hashCode 相同，它们并不一定相同（即：用 equals 比较返回 false）；

> 《Effective java》一书中这样说到：在每个覆盖了 equals() 方法的类中，也必须覆盖 hashCode() 方法，如果不这样做的话，就会违反 Object.hashCode 的通用的约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap，HashSet 和 HashTable

### java基本数据类型

Java 中有 8 种基本数据类型，分别为：

1. 6 种数字类型 ：`byte`、`short`、`int`、`long`、`float`、`double`
2. 1 种字符类型：`char`
3. 1 种布尔型：`boolean`。

这 8 种基本数据类型的默认值以及所占空间的大小如下：

| 基本类型  | 位数 | 字节 | 默认值  |
| --------- | ---- | ---- | ------- |
| `int`     | 32   | 4    | 0       |
| `short`   | 16   | 2    | 0       |
| `long`    | 64   | 8    | 0L      |
| `byte`    | 8    | 1    | 0       |
| `char`    | 16   | 2    | 'u0000' |
| `float`   | 32   | 4    | 0f      |
| `double`  | 64   | 8    | 0d      |
| `boolean` | 1    |      | false   |

另外，对于 `boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。

**注意：**

1. Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。
2. `char a = 'h'`char :单引号，`String a = "hello"` :双引号。

这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。

包装类型不赋值就是 `Null` ，而基本类型有默认值且不是 `Null`。

另外，这个问题建议还可以先从 JVM 层面来分析。

基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。

> 《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型 **（boolean、byte、char、short、int、float、long、double）**、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

### 自动装箱与拆箱

装箱：将基本类型用它们对应的引用类型包装起来，通过调用包装器的valueof()方法实现

拆箱：将包装类型转换为基本数据类型，通过调用包装器的xxxValue 方法实现（xxx代表对应的基本数据类型）

常见的面试问题：

```java
public class Main {
	public static void main (String[] args) {
		Integer i1 = 100;
		Integer i2 = 100;
		Integer i3 = 200;
	    Integer i4 = 200;
		System.out.printLn(i1 == i2); // true
		System.out.printLn(i3 == i4); // false
	}
}	

	通过阅读源码得知，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。
	上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。
```

###  8 种基本类型的包装类和常量池

 Java 基本类型的包装类的大部分都实现了常量池技术。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在[0,127]范围的缓存数据，`Boolean` 直接返回 `True` Or `False`。 

![img](https://camo.githubusercontent.com/1787ac3ea56e56450b185b8e6dccb0bfd4ce60cafe05ffdecf31f3e64c833724/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303432323136343534343834362e706e67) 

### 重载和重写的区别

| 区别点     | 重载方法 | 重写方法                                                     |
| ---------- | -------- | ------------------------------------------------------------ |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期   | 运行期                                                       |

### 值传递与引用传递

在java中，只有值传递.



